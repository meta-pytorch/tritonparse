# Copyright (c) Meta Platforms, Inc. and affiliates.

# pyre-strict

"""
Tests for extract_kernel_autotune_configs and match_autotune_config
in function_extractor.py.

These tests verify that compile params (num_warps, num_stages, etc.) are
correctly extracted from @triton.autotune configs, handling:
- Variable reference configs (configs=configs_var)
- Inline list configs (configs=[triton.Config(...), ...])
- Dynamic configs (configs=get_configs()) — should return None
- Multi-kernel files with separate config sets
- Matching the selected config by extracted_args
"""

import sys
import unittest
from types import ModuleType
from unittest.mock import MagicMock

# Ensure triton.language can be imported even when libtriton.so is unavailable.
# function_extractor.py → utils.py → triton.language at module level.
if "triton" not in sys.modules:
    _triton = ModuleType("triton")
    _triton.language = ModuleType("triton.language")  # type: ignore[attr-defined]
    sys.modules.setdefault("triton", _triton)
    sys.modules.setdefault("triton.language", _triton.language)  # type: ignore[attr-defined]
    # Stub out the attribute that utils.py reads (tl.int8, tl.float16, etc.)
    for attr in [
        "int1",
        "int8",
        "int16",
        "int32",
        "int64",
        "uint8",
        "uint16",
        "uint32",
        "uint64",
        "float8e4b15",
        "float8e4nv",
        "float8e4b8",
        "float8e5",
        "float8e5b16",
        "float16",
        "bfloat16",
        "float32",
        "float64",
    ]:
        setattr(sys.modules["triton.language"], attr, MagicMock(name=f"tl.{attr}"))

from tritonparse.reproducer.function_extractor import (
    extract_kernel_autotune_configs,
    match_autotune_config,
)


class TestExtractKernelAutotuneConfigs(unittest.TestCase):
    """Test extraction of compile params from @triton.autotune configs."""

    def test_variable_reference_configs(self) -> None:
        """Test configs defined as a module-level variable referenced by decorator."""
        source = """\
import triton

configs = [
    triton.Config({"BLOCK_M": 256, "BLOCK_N": 128}, num_warps=4, num_stages=0),
    triton.Config({"BLOCK_M": 128, "BLOCK_N": 64}, num_warps=8, num_stages=2),
]

@triton.autotune(configs=configs, key=["N_CTX"])
@triton.jit
def my_kernel(data, N_CTX, BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr):
    pass
"""
        result = extract_kernel_autotune_configs(source, "my_kernel")
        self.assertIsNotNone(result)
        self.assertEqual(len(result), 2)

        self.assertEqual(result[0]["BLOCK_M"], 256)
        self.assertEqual(result[0]["BLOCK_N"], 128)
        self.assertEqual(result[0]["num_warps"], 4)
        self.assertEqual(result[0]["num_stages"], 0)

        self.assertEqual(result[1]["BLOCK_M"], 128)
        self.assertEqual(result[1]["num_warps"], 8)
        self.assertEqual(result[1]["num_stages"], 2)

    def test_inline_list_configs(self) -> None:
        """Test configs defined inline in the decorator."""
        source = """\
import triton

@triton.autotune(
    configs=[
        triton.Config({"BLOCK_M": 64}, num_warps=4),
        triton.Config({"BLOCK_M": 128}, num_warps=4),
    ],
    key=["N"],
)
@triton.jit
def my_kernel(data, N, BLOCK_M: tl.constexpr):
    pass
"""
        result = extract_kernel_autotune_configs(source, "my_kernel")
        self.assertIsNotNone(result)
        self.assertEqual(len(result), 2)
        self.assertEqual(result[0]["num_warps"], 4)
        self.assertEqual(result[1]["num_warps"], 4)

    def test_dynamic_configs_returns_none(self) -> None:
        """Test that configs generated by a function call return None."""
        source = """\
import triton

def get_configs():
    return [triton.Config({"BLOCK_M": 64}, num_warps=4)]

@triton.autotune(configs=get_configs(), key=["N"])
@triton.jit
def my_kernel(data, N, BLOCK_M: tl.constexpr):
    pass
"""
        result = extract_kernel_autotune_configs(source, "my_kernel")
        self.assertIsNone(result)

    def test_no_autotune_returns_none(self) -> None:
        """Test that a kernel without @triton.autotune returns None."""
        source = """\
import triton

@triton.jit
def my_kernel(data):
    pass
"""
        result = extract_kernel_autotune_configs(source, "my_kernel")
        self.assertIsNone(result)

    def test_function_not_found_returns_none(self) -> None:
        """Test that a non-existent function name returns None."""
        source = """\
import triton

@triton.jit
def my_kernel(data):
    pass
"""
        result = extract_kernel_autotune_configs(source, "nonexistent_kernel")
        self.assertIsNone(result)

    def test_multi_kernel_isolation(self) -> None:
        """Test that configs from different kernels in the same file are isolated."""
        source = """\
import triton

configs_fwd = [
    triton.Config({"BLOCK_M": 256}, num_warps=4, num_stages=0),
]

configs_bwd = [
    triton.Config({"BLOCK_M": 128}, num_warps=8, num_stages=2),
]

@triton.autotune(configs=configs_fwd, key=["N"])
@triton.jit
def kernel_fwd(data, N, BLOCK_M: tl.constexpr):
    pass

@triton.autotune(configs=configs_bwd, key=["N"])
@triton.jit
def kernel_bwd(data, N, BLOCK_M: tl.constexpr):
    pass
"""
        result_fwd = extract_kernel_autotune_configs(source, "kernel_fwd")
        self.assertIsNotNone(result_fwd)
        self.assertEqual(len(result_fwd), 1)
        self.assertEqual(result_fwd[0]["num_warps"], 4)
        self.assertEqual(result_fwd[0]["BLOCK_M"], 256)

        result_bwd = extract_kernel_autotune_configs(source, "kernel_bwd")
        self.assertIsNotNone(result_bwd)
        self.assertEqual(len(result_bwd), 1)
        self.assertEqual(result_bwd[0]["num_warps"], 8)
        self.assertEqual(result_bwd[0]["BLOCK_M"], 128)

    def test_non_constant_values_skipped(self) -> None:
        """Test that non-constant values (e.g., pre_hook=func) are skipped."""
        source = """\
import triton

def my_hook(nargs):
    pass

configs = [
    triton.Config({"BLOCK_M": 256}, num_warps=4, pre_hook=my_hook),
]

@triton.autotune(configs=configs, key=["N"])
@triton.jit
def my_kernel(data, N, BLOCK_M: tl.constexpr):
    pass
"""
        result = extract_kernel_autotune_configs(source, "my_kernel")
        self.assertIsNotNone(result)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]["num_warps"], 4)
        self.assertEqual(result[0]["BLOCK_M"], 256)
        # pre_hook should NOT be in the result (non-constant)
        self.assertNotIn("pre_hook", result[0])

    def test_syntax_error_returns_none(self) -> None:
        """Test that invalid source code returns None."""
        result = extract_kernel_autotune_configs("def invalid(:", "invalid")
        self.assertIsNone(result)

    def test_duplicate_variable_name_uses_first_assignment(self) -> None:
        """Test that when a configs variable is assigned multiple times,
        ALL configs are collected and the correct one matched by extracted_args.

        This reproduces the real-world pattern where blackwell-fa-ws-pipelined-persistent_test.py
        has 'configs = [triton.Config(...), ...]' at line 42 and 'configs = []' at line 2133.
        """
        source = """\
import triton

configs = [
    triton.Config({"BLOCK_M": 256}, num_warps=4, num_stages=0),
]

@triton.autotune(configs=configs, key=["N"])
@triton.jit
def my_kernel(data, N, BLOCK_M: tl.constexpr):
    pass

# Later in the file, configs is reassigned to empty list
configs = []
"""
        result = extract_kernel_autotune_configs(source, "my_kernel")
        self.assertIsNotNone(
            result, "Should collect configs from the non-empty assignment"
        )
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]["num_warps"], 4)
        self.assertEqual(result[0]["BLOCK_M"], 256)

    def test_multiple_assignments_same_variable_collects_all(self) -> None:
        """Test that configs from all assignments to the same variable are collected.

        When multiple kernels reuse the same variable name with different configs,
        all configs are collected and match_autotune_config disambiguates.
        """
        source = """\
import triton

configs = [
    triton.Config({"BLOCK_M": 64}, num_warps=4),
]

@triton.autotune(configs=configs, key=["N"])
@triton.jit
def kernel_a(data, N, BLOCK_M: tl.constexpr):
    pass

configs = [
    triton.Config({"BLOCK_M": 128}, num_warps=8),
]

@triton.autotune(configs=configs, key=["N"])
@triton.jit
def kernel_b(data, N, BLOCK_M: tl.constexpr):
    pass

configs = []
"""
        # Both kernels reference "configs", so we get ALL configs from all assignments
        result_a = extract_kernel_autotune_configs(source, "kernel_a")
        self.assertIsNotNone(result_a)
        self.assertEqual(len(result_a), 2)  # Both non-empty assignments collected

        result_b = extract_kernel_autotune_configs(source, "kernel_b")
        self.assertIsNotNone(result_b)
        self.assertEqual(len(result_b), 2)  # Same — both collected

        # match_autotune_config uses extracted_args to pick the right one
        match_a = match_autotune_config(
            result_a, {"BLOCK_M": {"type": "int", "value": 64}}
        )
        self.assertIsNotNone(match_a)
        self.assertEqual(match_a["num_warps"], 4)

        match_b = match_autotune_config(
            result_b, {"BLOCK_M": {"type": "int", "value": 128}}
        )
        self.assertIsNotNone(match_b)
        self.assertEqual(match_b["num_warps"], 8)


class TestMatchAutotuneConfig(unittest.TestCase):
    """Test matching the selected config against extracted_args."""

    def test_all_configs_agree(self) -> None:
        """Test strategy 1: all configs have the same compile param values."""
        configs = [
            {"BLOCK_M": 256, "GROUP_SIZE_N": 1, "num_warps": 4, "num_stages": 0},
            {"BLOCK_M": 256, "GROUP_SIZE_N": 4, "num_warps": 4, "num_stages": 0},
        ]
        extracted_args = {
            "BLOCK_M": {"type": "int", "value": 256},
            "GROUP_SIZE_N": {"type": "int", "value": 4},
        }
        result = match_autotune_config(configs, extracted_args)
        self.assertIsNotNone(result)
        self.assertEqual(result["num_warps"], 4)
        self.assertEqual(result["num_stages"], 0)

    def test_different_num_warps_match_by_dict_params(self) -> None:
        """Test strategy 2: match by dict params when compile params differ."""
        configs = [
            {"BLOCK_M": 256, "num_warps": 4},
            {"BLOCK_M": 128, "num_warps": 8},
        ]
        extracted_args = {
            "BLOCK_M": {"type": "int", "value": 128},
        }
        result = match_autotune_config(configs, extracted_args)
        self.assertIsNotNone(result)
        self.assertEqual(result["num_warps"], 8)

    def test_no_match_returns_none(self) -> None:
        """Test that no matching config returns None."""
        configs = [
            {"BLOCK_M": 256, "num_warps": 4},
            {"BLOCK_M": 128, "num_warps": 8},
        ]
        extracted_args = {
            "BLOCK_M": {"type": "int", "value": 512},
        }
        result = match_autotune_config(configs, extracted_args)
        self.assertIsNone(result)

    def test_empty_configs_returns_none(self) -> None:
        """Test that empty configs list returns None."""
        result = match_autotune_config([], {})
        self.assertIsNone(result)

    def test_match_with_multiple_dict_params(self) -> None:
        """Test matching with multiple dict params for disambiguation."""
        configs = [
            {"BLOCK_M": 256, "BLOCK_N": 128, "GROUP_SIZE_N": 1, "num_warps": 4},
            {"BLOCK_M": 256, "BLOCK_N": 128, "GROUP_SIZE_N": 4, "num_warps": 4},
            {
                "BLOCK_M": 256,
                "BLOCK_N": 128,
                "NUM_BUFFERS_KV": 6,
                "GROUP_SIZE_N": 1,
                "num_warps": 4,
            },
            {
                "BLOCK_M": 256,
                "BLOCK_N": 128,
                "NUM_BUFFERS_KV": 6,
                "GROUP_SIZE_N": 4,
                "num_warps": 4,
            },
        ]
        extracted_args = {
            "BLOCK_M": {"type": "int", "value": 256},
            "BLOCK_N": {"type": "int", "value": 128},
            "NUM_BUFFERS_KV": {"type": "int", "value": 6},
            "GROUP_SIZE_N": {"type": "int", "value": 4},
        }
        result = match_autotune_config(configs, extracted_args)
        self.assertIsNotNone(result)
        self.assertEqual(result["num_warps"], 4)


if __name__ == "__main__":
    unittest.main()
